module Runner ( run ) where

import Control.Lens
import Data.Foldable as F
import Data.Functor
import Distribution.Nixpkgs.Haskell.FromStack
import Distribution.Nixpkgs.Haskell.FromStack.Package
import Distribution.Nixpkgs.Haskell.Stack
import Distribution.Nixpkgs.Haskell.Stack.PrettyPrinting as PP
import Distribution.Version (Version)
import Distribution.Compiler (AbiTag(..), unknownCompilerInfo)
import Distribution.Package (mkPackageName, pkgName)
import Language.Nix as Nix
import Options.Applicative
import Runner.Cli
import Stack.Config
import Stack.Types
import Stackage.Types
import System.FilePath as Path
import System.IO (withFile, IOMode(..), hPutStrLn, hPrint)
import Text.PrettyPrint.HughesPJClass (render)

import qualified Data.Set as Set
import qualified Data.Map as Map
import qualified Stackage2nix as S2n


run :: IO ()
run = do
  opts <- execParser pinfo
  stackYaml <- envStackYaml >>= \case
    Just p  -> putStrLn "Getting project config file from STACK_YAML environment" $> p
    Nothing -> pure $ opts ^. optStackYaml
  stackConf <- either fail pure =<< readStackConfig stackYaml
  let
    s2nOpts = mkS2nOptions stackConf opts
  (buildPlan, packageSetConfig) <- S2n.run s2nOpts
  -- generate haskell packages override
  let
    overrideConfig = mkOverrideConfig opts (siGhcVersion $ bpSystemInfo buildPlan)
    pkgConfig = StackPackagesConfig
      { _spcHaskellResolver   = const True
      , _spcNixpkgsResolver   = \i -> Just (Nix.binding # (i, Nix.path # [i]))
      , _spcTargetPlatform    = opts ^. optPlatform
      , _spcTargetCompiler    = unknownCompilerInfo (opts ^. optCompilerId) NoAbiTag
      , _spcFlagAssignment    = []
      , _spcDoCheckPackages   = opts ^. optDoCheckPackages
      , _spcDoHaddockPackages = opts ^. optDoHaddockPackages
      , _spcDoCheckStackage   = opts ^. optDoCheckStackage
      , _spcDoHaddockStackage = opts ^. optDoHaddockStackage
      }
  packages <- traverse (packageDerivation pkgConfig (opts ^. optHackageDb))
    $ stackConf ^. scPackages
  let out = PP.overrideHaskellPackages overrideConfig packages
  withFile (opts ^. optOutDerivation) WriteMode $ \h -> do
    hPutStrLn h ("# Generated by stack2nix from " ++ stackYaml ^. syFilePath)
    hPrint h out
  let
    reachable = fmap mkPackageName
      $ F.toList . F.foldr1 Set.union
      $ nodeDepends . mkNode <$> packages
    s2nLoader mHash pkgId =
      if pkgName pkgId `elem` reachable
      then packageLoader packageSetConfig Nothing pkgId
      else packageLoader packageSetConfig mHash pkgId
    s2nPackageSetConfig = packageSetConfig { packageLoader = s2nLoader }
  -- generate stackage packages
  nodes <- traverse (uncurry (buildNodeM s2nPackageSetConfig))
    $ Map.toList (bpPackages buildPlan)
  withFile (opts ^. optOutStackagePackages) WriteMode $ \h -> do
    hPutStrLn h ("# Generated by stack2nix from " ++ S2n.optBuildPlanFile s2nOpts)
    hPutStrLn h $ render $ pPrintOutPackages (view nodeDerivation <$> nodes)
  withFile (opts ^. optOutStackageConfig) WriteMode $ \h -> do
    hPutStrLn h ("# Generated by stack2nix from " ++ S2n.optBuildPlanFile s2nOpts)
    hPutStrLn h $ render $ pPrintOutConfig (bpSystemInfo buildPlan) nodes

mkOverrideConfig :: Options -> Version -> OverrideConfig
mkOverrideConfig opts ghcVersion = OverrideConfig
  { _ocGhc              = ghcVersion
  , _ocStackagePackages = opts ^. optOutStackagePackages
  , _ocStackageConfig   = opts ^. optOutStackageConfig }

mkS2nOptions :: StackConfig -> Options -> S2n.Options
mkS2nOptions conf opts = S2n.Options
  { S2n.optBuildPlanFile     =
    (opts ^. optLtsHaskellRepo) Path.</>
    (conf ^. scResolver . to unStackResolver) Path.<.>
    ".yaml"
  , S2n.optAllCabalHashes    = opts ^. optAllCabalHashesRepo
  , S2n.optNixpkgsRepository = opts ^. optNixpkgsRepository
  , S2n.optNixpkgsMap        = Nothing
  , S2n.optOutPackages       = opts ^. optOutStackagePackages
  , S2n.optOutConfig         = opts ^. optOutStackageConfig
  , S2n.optDoCheck           = opts ^. optDoCheckStackage
  , S2n.optDoHaddock         = opts ^. optDoHaddockStackage
  }
