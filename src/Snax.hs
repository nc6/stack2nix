{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}  -- One more extension.
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE RecordWildCards    #-}
{-# LANGUAGE TypeOperators      #-}

module Snax where

import Control.Lens ((^.), view)
import Data.Coerce (coerce)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import qualified Distribution.Nixpkgs.Haskell.Snax as SL
import Distribution.Nixpkgs.Haskell.FromStack
import Distribution.Nixpkgs.Haskell.FromStack.Package
import Distribution.Nixpkgs.Haskell.Stack
import Distribution.Nixpkgs.Haskell.Stack.PrettyPrinting as PP

import qualified LtsHaskell as LH

import qualified Snax.Options as O
import Options.Generic (unwrapRecord)

import Stack.Config
import Stackage.Types

import System.Directory (createDirectoryIfMissing)
import System.FilePath ((</>), (<.>))
import System.IO (withFile, IOMode(..), hPutStrLn, hPrint)

import Text.PrettyPrint.HughesPJClass (render)

run :: O.Options -> IO ()
run O.Init{..} = do
  createDirectoryIfMissing True SL.libPath
  SL.writeRepo (SL.allCabalHashes _allCabalHashes)
  SL.writeRepo (SL.ltsHaskell _ltsHaskell)
  withFile (SL.libPath </> "fetch-repo.nix") WriteMode $ \h -> do
    hPutStrLn h "# Generated by snax"
    hPrint h SL.fetchRepo

  withFile (SL.libPath </> "default.nix") WriteMode $ \h -> do
    hPutStrLn h "# Generated by snax"
    hPrint h SL.libNix
-- | Extract the resolver out of stack.yaml
run opts@O.ExtractResolver{..} = let
    stackYaml = opts ^. O.stackYamlParsed
  in do
    stackConf <- either fail pure =<< readStackConfig stackYaml
    putStrLn . unStackResolver $ stackConf ^. scResolver
-- | Generate stackage.nix and overrides.nix for a given resolver
run opts@(O.GenerateStackage{..}) = let
    nixpkgs = fromMaybe "<nixpkgs>" _nixpkgsRepository
    buildPlanFile = LH.buildPlanFilePath _ltsHaskellPath $ coerce _resolver
    s2nPackageConfig = PackageConfig
      { enableCheck   = _doCheckStackage
      , enableHaddock = _doHaddockStackage
      }
  in do
    buildPlan <- LH.loadBuildPlan buildPlanFile
    packageSetConfig <- LH.buildPackageSetConfig
      _allCabalHashesPath
      nixpkgs
      buildPlan
    let
    -- generate stackage packages
    nodes <- traverse (uncurry (buildNodeM packageSetConfig s2nPackageConfig))
      $ Map.toList (bpPackages buildPlan)
    withFile (SL.libPath </> "stackage.nix") WriteMode $ \h -> do
      hPutStrLn h ("# Generated by snax from " ++ buildPlanFile)
      hPutStrLn h $ render $ pPrintOutPackages (view nodeDerivation <$> nodes)
    withFile (SL.libPath </> "overrides.nix") WriteMode $ \h -> do
      hPutStrLn h ("# Generated by snax from " ++ buildPlanFile)
      hPutStrLn h $ render $ pPrintOutConfig (bpSystemInfo buildPlan) nodes
