{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}  -- One more extension.
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE RecordWildCards    #-}
{-# LANGUAGE TypeOperators      #-}

import Control.Lens ((^.), view)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import qualified Distribution.Nixpkgs.Haskell.Snax as Snax
import Distribution.Nixpkgs.Haskell.FromStack
import Distribution.Nixpkgs.Haskell.FromStack.Package
import Distribution.Nixpkgs.Haskell.Stack
import Distribution.Nixpkgs.Haskell.Stack.PrettyPrinting as PP

import qualified Options as O
import Options.Generic (unwrapRecord)

import Stack.Config
import qualified Stackage2nix as S2n
import Stackage.Types

import System.Directory (createDirectoryIfMissing)
import System.FilePath ((</>), (<.>))
import System.IO (withFile, IOMode(..), hPutStrLn, hPrint)

import Text.PrettyPrint.HughesPJClass (render)

main :: IO ()
main = do
  x <- unwrapRecord "Snax"
  run x

run :: O.Options -> IO ()
run O.Init{..} = do
  createDirectoryIfMissing True Snax.libPath
  Snax.writeRepo (Snax.allCabalHashes _allCabalHashes)
  Snax.writeRepo (Snax.ltsHaskell _ltsHaskell)
  withFile (Snax.libPath </> "fetch-repo.nix") WriteMode $ \h -> do
    hPutStrLn h "# Generated by snax"
    hPrint h Snax.fetchRepo

  withFile (Snax.libPath </> "default.nix") WriteMode $ \h -> do
    hPutStrLn h "# Generated by snax"
    hPrint h Snax.libNix
-- | Extract the resolver out of stack.yaml
run opts@O.ExtractResolver{..} = let
    stackYaml = opts ^. O.stackYamlParsed
  in do
    stackConf <- either fail pure =<< readStackConfig stackYaml
    putStrLn . unStackResolver $ stackConf ^. scResolver
-- | Generate stackage.nix and overrides.nix for a given resolver
run opts@(O.GenerateStackage{..}) = let
    nixpkgs = fromMaybe "<nixpkgs>" _nixpkgsRepository
    s2nOpts = S2n.Options
      { S2n.optBuildPlanFile     = _ltsHaskellPath
                                </> _resolver <.> ".yaml"
      , S2n.optAllCabalHashes    = _allCabalHashesPath
      , S2n.optNixpkgsRepository = nixpkgs
      , S2n.optNixpkgsMap        = Nothing
      , S2n.optOutPackages       = Snax.libPath </> "stackage.nix"
      , S2n.optOutConfig         = Snax.libPath </> "overrides.nix"
      , S2n.optDoCheck           = _doCheckStackage
      , S2n.optDoHaddock         = _doHaddockStackage
      }
   in do
    (buildPlan, packageSetConfig) <- S2n.run s2nOpts
    let
    -- generate stackage packages
    nodes <- traverse (uncurry (buildNodeM packageSetConfig))
      $ Map.toList (bpPackages buildPlan)
    withFile (Snax.libPath </> "stackage.nix") WriteMode $ \h -> do
      hPutStrLn h ("# Generated by snax from " ++ S2n.optBuildPlanFile s2nOpts)
      hPutStrLn h $ render $ pPrintOutPackages (view nodeDerivation <$> nodes)
    withFile (Snax.libPath </> "overrides.nix") WriteMode $ \h -> do
      hPutStrLn h ("# Generated by snax from " ++ S2n.optBuildPlanFile s2nOpts)
      hPutStrLn h $ render $ pPrintOutConfig (bpSystemInfo buildPlan) nodes
